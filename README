# lab2总计

本次lab2主要难度在于系统调用syscall的过程
先讲trace的调用过程

- 在user/user.h做函数声明
- Makefile调用usys.pl（perl脚本）生成usys.S，里面写了具体实现，通过ecall进入kernel，通过设置寄存器a7的值，表明调用哪个system call  
- ecall表示一种特殊的trap，转到kernel/syscall.c:syscall执行  
- syscall.c中有个函数指针数组，即一个数组中存放了所有指向system call实现函数的指针，通过寄存器a7的值定位到某个函数指针，通过函数指针调用函数
其中，SYS_+syscall 代表的是该syscall的标识,添加一个syscall需要我们在syscall.h中做出对应的标识

sysinfotest的调用就同理了，我们只需要新增两个获取内存和获取线程数的函数，然后新增sysinfotest的标识以及指向的函数和对应实现的函数，就大功告成
